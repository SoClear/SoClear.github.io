# 3.1 栈

## 3.1.4 本节试题精选

- 01. 栈和队列具有相同的（）  
A. 抽象数据类型 B. 逻辑结构 C. 存储结构 D. 运算

- 03. 栈的初态和终态均为空，以 I 和 O 分别表示入栈和出栈，则出入栈的操作序列可表示为由 I 和 O 组成的序列，可以操作的序列称为合法序列，否则称为非法序列。  
1）下面所示的序列中哪些是合法的?  
A. IOIIOIOO B. IOOIOIIO C. IIIOIOIO D. IIIOOIOO  
2）通过对 1）的分析, 写出一个算法, 判定所给的操作序列是否合法。若合法, 返回true，否则返回 false (假定被判定的操作序列已存入一维数组中 )。

- 04. 设单链表的表头指针为 L ，结点结构由 data 和 next 两个域构成，其中 data 域为字符型。 试设计算法判断该链表的全部 n 个字符是否中心对称。例如 xyx、xyyx 都是中心对称。

## 3.1.5 答案与解析

- 01 栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同。它们的存储结构可以随意选用顺序表或者链表实现，所以栈和队列的存储结构不一定相同。

- 03
    1) A、D 合法,而 B、C 不合法。在 B 中,先入栈 1 次,再连续出栈 2 次,错误。在 C 中, 入栈和出栈次数不一致,  **会导致最终的栈不空** 。A、D 均为合法序列, 请自行模拟。注意: 在找作过程中, 入栈次数一定大于或等于出栈次数; 结束时, 栈一定为空。  
    2) 〖另解〗入栈后，栈内元素个数加 1 ；出栈后，栈内元素个数减 1 ，因此可将判定一组出入栈序列是否合法转化为一组由+1 、-1 组成的序列，它的任意前缀子序列的累加和不小于 0 （每次出栈或入栈操作后判断）则合法；否则非法。

- 04
    算法思想: 使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次进栈。在处理链表的后一半元素时, 当访问到链表的一个元素后, 就从栈中弹出一个元素, 两个元素比较, 若相等, 则将链表中的下一个元素与栈中再弹出的元素比较, 直至链表到尾。这时若栈是空栈, 则得出链表中心对称的结论; 否则, 当链表中的一个元素与栈中弹出元素不等时, 结论为链表非中心对称，结束算法的执行。

    ```c
    int dc(LinkList L, int n) {
        int i;
        char s[n/2]; // s字符栈
        LNode *p = L->next; // 工作指针p，只想待处理的当前元素
        for (i = 0; i < n/2; i++) { // 将前半部分元素依次进栈
            s[i] = p->data;
            p = p->next;
        }
        i--; // 恢复最后的i值
        if(n % 2 == 1) { // 奇数个元素时, 跳过中间元素
            p = p->next;
        }
        while (p!=NULL && s[i] == p->data) { // 栈顶元素与链表元素比较
            i--; // i充当栈顶指针
            p = p->next;
        }
        if (i == -1) { // 栈为空
            return 1; // 链表中心对称
        } else {
            return 0; // 链表非中心对称
        }
    }
    ```

    算法先将 “链表的前一半” 元素 (字符) 进栈。当 n 为偶数时,前一半和后一半的个数相同; 当 n 为奇数时,链表中心结点字符不必比较,移动链表指针到下一字符开始比较。比较过程中遇到不相等时, 立即退出 while 循环, 不再进行比较。

    本题也可以先将单链表中的元素全部入栈, 然后扫描单链表 L 并比较, 直到比较到单链表 L 尾为止, 但算法需要两次扫描单链表 L, 效率不及上述算法高。
