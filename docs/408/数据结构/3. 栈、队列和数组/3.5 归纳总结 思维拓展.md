# 归纳总结 思维拓展

## 归纳总结

本章所讲的几种数据结构类型是线性表的应用和推广, 在考试中主要以选择题形式进行考查, 但栈和队列也仍然有可能出现在算法设计题中。很多读者看到课本上有好多个函数时很恐惧, 若考到了栈或队列的大题, 难道要把每个操作的函数都写出来吗?

其实, 在考试中, 栈或队列都是作为一个工具来解决其他问题的, 我们可以把栈或队列的声明和操作写得很简单, 而不必分函数写出。以顺序栈的操作为例:

（1）声明一个栈并初始化:

```c
Elemtype stack[maxSize]; int top=-1; //两句话连声明带初始化都有了
```

（2）元素进栈:

```c
stack[++top]=x; //仅一句话即实现进栈操作
```

（3）元素 x 出栈:

```c
x=stack[top--]; //单目运算符在变量之前表示 “先运算后使用”, 之后则相反
```

对于链式栈, 同样只需定义一个结构体, 然后从讲解中摘取必要的语句组合在自己的函数代码中即可。另外, 在考研真题中, 链式栈出现的概率要比顺序栈低得多, 因此大家应该有所侧重, 多训练与顺序栈相关的题目。

## 思维拓展

设计一个栈,使它可以在 $O\left( 1\right)$ 的时间复杂度内实现 Push、Pop 和 min 操作。所谓 min 操作, 是指得到栈中最小的元素。

提示: 使用双栈, 两个栈是同步关系。主栈是普通栈, 用来实现栈的基本操作 Push 和 Pop; 辅助栈用来记录同步的最小值 min,例如元素 x 进栈,则辅助栈 `stack_min[top++]= (x<min) ?x:min;` 即在每次 Push 中, 都将当前最小元素放到 stack_min 的栈顶。在主栈中 Pop 最小元素 y 时, stack_min 栈中相同位置的最小元素 y 也会随着 top--而出栈。因此 stack_min 的栈顶元素必然是 y 之前入栈的最小元素。本题是典型的以空间换时间的算法。
